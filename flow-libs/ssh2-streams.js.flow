/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 *
 * @flow
 */

// Type definitions for ssh2-streams v0.1.9
// Project: https://github.com/mscdex/ssh2-streams
// TypeScript Definitions by: Ron Buckton <https://github.com/rbuckton>

declare module 'ssh2-streams' {
  declare type ParsedKey = {
    fulltype: string;
    type: string;
    extra: string;
    comment: string;
    encryption: string;
    private: Buffer;
    privateOrig: Buffer;
    public: Buffer;
    publicOrig: Buffer;
    ppk?: boolean;
    privateMAC?: string;
  }

  declare class SSH2Stream extends stream$Transform {
    /**
     * The number of bytes sent since the last keying. This metric can be useful in determining when to call rekey().
     */
    bytesSent: number;

    /**
     * The number of bytes received since the last keying. This metric can be useful in determining when to call rekey().
     */
    bytesReceived: number;

    /**
     * Creates and returns a new SSH2Stream instance.
     */
    constructor(config?: SSH2StreamConfig): void;

    /**
     * (Client/Server)
     * Writes a dummy GLOBAL_REQUEST packet (specifically "keepalive@openssh.com") that requests a reply.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    ping(): boolean;

    /**
     * (Client/Server)
     * Writes a disconnect packet and closes the stream.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    disconnect(reasonCode?: number): boolean;

    /**
     * (Client/Server)
     * Starts the re-keying process. Incoming/Outgoing packets are buffered until the re-keying
     * process has finished. Returns `false` to indicate that no more packets should be written
     * until the `NEWKEYS` event is seen.
     */
    rekey(): boolean;

    /**
     * (Client/Server)
     * Writes a request success packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    requestSuccess(data?: Buffer): boolean;

    /**
     * (Client/Server)
     * Writes a request failure packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    requestFailure(): boolean;

    /**
     * (Client/Server)
     * Writes a channel success packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    channelSuccess(channel: number): boolean;

    /**
     * (Client/Server)
     * Writes a channel failure packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    channelFailure(channel: number): boolean;

    /**
     * (Client/Server)
     * Writes a channel EOF packet for the given `channel`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    channelEOF(channel: number): boolean;

    /**
     * (Client/Server)
     * Writes a channel close packet for the given `channel`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    channelClose(channel: number): boolean;

    /**
     * (Client/Server)
     * Writes a channel window adjust packet for the given `channel` where `amount` is the
     * number of bytes to add to the channel window.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    channelWindowAdjust(channel: number, amount: number): boolean;

    /**
     * (Client/Server)
     * Writes a channel data packet for the given `channel` where `data` is a _Buffer_ or _string_.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    channelData(channel: number, data: string | Buffer): boolean;

    /**
     * (Client/Server)
     * Writes a channel extended data packet for the given `channel` where `data is a _Buffer_
     * or _string_.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    channelExtData(channel: number, data: string | Buffer, type: number): boolean;

    /**
     * (Client/Server)
     * Writes a channel open confirmation packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    channelOpenConfirm(
      remoteChannel: number,
      localChannel: number,
      initWindow: number,
      maxPacket: number
    ): boolean;

    /**
     * (Client/Server)
     * Writes a channel open failure packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    channelOpenFail(
      remoteChannel: number,
      reasonCode: number,
      description?: string,
      lang?: string
    ): boolean;

    /**
     * (Client-only)
     * Writes a service request packet for `serviceName`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    service(serviceName: string): boolean;

    /**
     * (Client-only)
     * Writes a tcpip forward global request packet. `wantReply` defaults to `true`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    tcpipForward(
      bindAddr: string,
      bindPort: number,
      wantReply?: boolean
    ): boolean;

    /**
     * (Client-only)
     * Writes a cancel tcpip forward global request packet. `wantReply` defaults to `true`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    cancelTcpipForward(
      bindAddr: string,
      bindPort: number,
      wantReply?: boolean
    ): boolean;

    /**
     * (Client-only)
     * Writes a password userauth request packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    authPassword(username: string, password: string): boolean;

    /**
     * (Client-only)
     * Writes a publickey userauth request packet. `pubKey` is the object returned from using
     * `utils.parseKey()` on a private or public key. If `cbSign` is not present, a pubkey
     * check userauth packet is written. Otherwise `cbSign` is called with `(blob, callback)`,
     * where `blob` is the data to sign with the private key and the resulting signature
     * _Buffer_ is passed to `callback` as the first argument.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    authPK(
      username: string,
      pubKey: ParsedKey,
      cbSign?: (
        blob: Buffer,
        callback: (signedBlob: Buffer) => mixed
      ) => mixed
    ): boolean;

    /**
     * (Client-only)
     * Writes a hostbased userauth request packet. `pubKey` is the object returned from using
     * `utils.parseKey()` on a private or public key. `cbSign` is called with `(blob, callback)`,
     * where `blob` is the data to sign with the private key and the resulting signature
     * _Buffer_ is passed to `callback` as the first argument.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    authHostBased(
      username: string,
      pubKey: ParsedKey,
      localHostname: string,
      localUsername: string,
      cbSign?: (
        blob: Buffer,
        callback: (signedBlob: Buffer) => mixed
      ) => mixed
    ): boolean;

    /**
     * (Client-only)
     * Writes a keyboard-interactive userauth request packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    authKeyboard(username: string): boolean;

    /**
     * (Client-only)
     * Writes a "none" userauth request packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    authNone(username: string): boolean;

    /**
     * (Client-only)
     * Writes a userauth info response packet. `responses` is an _array_ of zero or more strings
     * corresponding to responses to prompts previously sent by the server.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    authInfoRes(responses?: string[]): boolean;

    /**
     * (Client-only)
     * Writes a direct tcpip channel open packet. `config` must contain `srcIP`, `srcPort`,
     * `dstIP`, and `dstPort`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    directTcpip(
      channel: number,
      initWindow: number,
      maxPacket: number,
      config: TcpipForwardingConfig
    ): boolean;

    /**
     * (Client-only)
     * Writes a session channel open packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    session(channel: number, initWindow: number, maxPacket: number): boolean;

    /**
     * (Client-only)
     * Writes an `auth-agent-req@openssh.com` channel request packet. `wantReply` defaults to
     * `true`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    openssh_agentForward(channel: number, wantReply?: boolean): boolean;

    /**
     * (Client-only)
     * Writes a window change channel request packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    windowChange(
      channel: number,
      rows: number,
      cols: number,
      height: number,
      width: number
    ): boolean;

    /**
     * (Client-only)
     * Writes a pty channel request packet. If `terminalType` is falsey, `vt100` is used.
     * `terminalModes` can be the raw bytes, an _object_ of the terminal modes to set, or a falsey value for no modes. `wantReply` defaults to `true`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    pty(
      channel: number,
      rows: number,
      cols: number,
      height: number,
      width: number,
      terminalType?: string,
      terminalModes?: any,
      wantReply?: boolean
    ): boolean;

    /**
     * (Client-only)
     * Writes an env channel request packet. `value` can be a _string_ or _Buffer_. `wantReply`
     * defaults to `true`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    env(
      channel: number,
      key: string,
      value: string | Buffer,
      wantReply?: boolean
    ): boolean;

    /**
     * (Client-only)
     * Writes a shell channel request packet. `wantReply` defaults to `true`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    shell(channel: number, wantReply?: boolean): boolean;

    /**
     * (Client-only)
     * Writes an exec channel request packet. `wantReply` defaults to `true`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    exec(channel: number, command: string, wantReply?: boolean): boolean;

    /**
     * (Client-only)
     * Writes a signal channel request packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    signal(channel: number, signalName: string): boolean;

    /**
     * (Client-only)
     * Writes an X11 forward channel request packet. `wantReply` defaults to `true`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    x11Forward(
      channel: number,
      config: X11ForwardingConfig,
      wantReply?: boolean
    ): boolean;

    /**
     * (Client-only)
     * Writes a subsystem channel request packet. `name` is the name of the subsystem (e.g.
     * `sftp` or `netconf`). `wantReply` defaults to `true`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    subsystem(channel: number, name: string, wantReply?: boolean): boolean;

    /**
     * (Client-only)
     * Writes a no-more-sessions@openssh.com request packet. `wantReply` defaults to `true`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    openssh_noMoreSessions(wantReply?: boolean): boolean;

    /**
     * (Client-only)
     * Writes a streamlocal-forward@openssh.com request packet. `wantReply` defaults to `true`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    openssh_streamLocalForward(socketPath: string, wantReply?: boolean): boolean;

    /**
     * (Client-only)
     * Writes a cancel-streamlocal-forward@openssh.com request packet. `wantReply` defaults to
     * `true`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    openssh_cancelStreamLocalForward(
      socketPath: string,
      wantReply?: boolean
    ): boolean;

    /**
     * (Client-only)
     * Writes a direct-streamlocal@openssh.com channel open packet. `config` must contain
     * `socketPath`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    openssh_directStreamLocal(
      channel: number,
      initWindow: number,
      maxPacket: number,
      config: SocketForwardingConfig
    ): boolean;

    /**
     * (Server-only)
     * Writes a service accept packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    serviceAccept(serviceName: string): boolean;

    /**
     * (Server-only)
     * Writes a userauth failure packet. `authMethods` is an _array_ of authentication methods
     * that can continue.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    authFailure(authMethods?: string[], partialSuccess?: boolean): boolean;

    /**
     * (Server-only)
     * Writes a userauth success packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    authSuccess(): boolean;

    /**
     * (Server-only)
     * Writes a userauth PK OK packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    authPKOK(keyAlgorithm: string, keyData: Buffer): boolean;

    /**
     * (Server-only)
     * Writes a userauth info request packet. `prompts` is an array of `Prompt` objects.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    authInfoReq(name: string, instructions: string, prompts: Prompt[]): boolean;

    /**
     * (Server-only)
     * Writes a forwarded tcpip channel open packet. `info` must contain `boundAddr`,
     * `boundPort`, `remoteAddr`, and `remotePort`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    forwardedTcpip(
      channel: number,
      initWindow: number,
      maxPacket: number,
      info: ForwardedTcpip
    ): boolean;

    /**
     * (Server-only)
     * Writes an X11 channel open packet. `info` must contain `originAddr` and `originPort`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    x11(
      channel: number,
      initWindow: number,
      maxPacket: number,
      info: ForwardedX11
    ): boolean;

    /**
     * (Server-only)
     * Writes an forwarded-streamlocal@openssh.com channel open packet. `info` must contain
     * `socketPath`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    openssh_forwardedStreamLocal(
      channel: number,
      initWindow: number,
      maxPacket: number,
      info: ForwardedSocket
    ): boolean;

    /**
     * (Server-only)
     * Writes an exit status channel request packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    exitStatus(channel: number, exitCode: number): boolean;

    /**
     * (Server-only)
     * Writes an exit signal channel request packet.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    exitSignal(
      channel: number,
      signalName: string,
      coreDumped: boolean,
      errorMessage: string
    ): boolean;

    /**
     * (Client/Server)
     * Emitted when the protocol header is seen.
     */
    on(event: 'header', listener: (header: Header) => mixed): this;

    /**
     * (Client/Server)
     */
    on(
      event: 'GLOBAL_REQUEST',
      listener: (
        reqName: string,
        wantReply: boolean,
        request: ?(GlobalRequest | Buffer)
      ) => mixed
    ): this;

    /**
     * (Client/Server)
     */
    on(
      event: 'DISCONNECT',
      listener: (
        reason: string,
        reasonCode: number,
        description: string
      ) => mixed
    ): this;

    /**
     * (Client/Server)
     */
    on(event: 'DEBUG', listener: (message: string) => mixed): this;

    /**
     * (Client/Server)
     */
    on(event: 'NEWKEYS', listener: () => mixed): this;

    /**
     * (Client/Server)
     */
    on(
      event: 'REQUEST_SUCCESS',
      listener: (resData: Buffer) => mixed
    ): this;

    /**
     * (Client/Server)
     */
    on(event: 'REQUEST_FAILURE', listener: () => mixed): this;

    /**
     * (Client/Server)
     */
    on(
      event: 'CHANNEL_OPEN',
      listener: (channelInfo: ChannelOpenInfo) => mixed
    ): this;

    /**
     * (Client/Server)
     */
    on(
      event: 'CHANNEL_OPEN_CONFIRMATION:0',
      listener: (channelInfo: ChannelOpenConfirmationInfo) => mixed
    ): this;

    /**
     * (Client/Server)
     */
    on(
      event: 'CHANNEL_OPEN_FAILURE:0',
      listener: (failInfo: ChannelOpenFailureInfo) => mixed
    ): this;

    /**
     * (Client/Server)
     */
    on(
      event: 'CHANNEL_REQUEST:0',
      listener: (request: ChannelRequest) => mixed
    ): this;

    /**
     * (Client/Server)
     */
    on(
      event: 'CHANNEL_DATA:0',
      listener: (data: Buffer) => mixed
    ): this;

    /**
     * (Client/Server)
     */
    on(
      event: 'CHANNEL_EXTENDED_DATA:0',
      listener: (type: number, data: Buffer) => mixed
    ): this;

    /**
     * (Client/Server)
     */
    on(
      event: 'CHANNEL_WINDOW_ADJUST:0',
      listener: (bytesToAdd: number) => mixed
    ): this;

    /**
     * (Client/Server)
     */
    on(event: 'CHANNEL_SUCCESS:0', listener: () => mixed): this;

    /**
     * (Client/Server)
     */
    on(event: 'CHANNEL_FAILURE:0', listener: () => mixed): this;

    /**
     * (Client/Server)
     */
    on(event: 'CHANNEL_EOF:0', listener: () => mixed): this;

    /**
     * (Client/Server)
     */
    on(event: 'CHANNEL_CLOSE:0', listener: () => mixed): this;

    /**
     * (Client-only)
     * This event allows you to verify a host's key. If `callback` is called with `true`, the
     * handshake continues. Otherwise a disconnection will occur if `callback` is called with
     * `false`. The default behavior is to auto-allow any host key if there are no handlers
     * for this event.
     */
    on(
      event: 'fingerprint',
      listener: (
        hostKey: Buffer,
        callback: (success: boolean) => mixed
      ) => mixed
    ): this;

    /**
     * (Client-only)
     */
    on(
      event: 'SERVICE_ACCEPT',
      listener: (serviceName: string) => mixed
    ): this;

    /**
     * (Client-only)
     */
    on(
      event: 'USERAUTH_PASSWD_CHANGEREQ',
      listener: (message: string) => mixed
    ): this;

    /**
     * (Client-only)
     */
    on(
      event: 'USERAUTH_INFO_REQUEST',
      listener: (
        name: string,
        instructions: string,
        lang: string,
        prompts: Prompt[]
      ) => mixed
    ): this;

    /**
     * (Client-only)
     */
    on(event: 'USERAUTH_PK_OK', listener: () => mixed): this;

    /**
     * (Client-only)
     */
    on(event: 'USERAUTH_SUCCESS', listener: () => mixed): this;

    /**
     * (Client-only)
     */
    on(
      event: 'USERAUTH_FAILURE',
      listener: (
        methodsContinue: string[],
        partialSuccess: boolean
      ) => mixed
    ): this;

    /**
     * (Client-only)
     */
    on(
      event: 'USERAUTH_BANNER',
      listener: (message: string) => mixed
    ): this;

    /**
     * (Server-only)
     */
    on(
      event: 'SERVICE_REQUEST',
      listener: (serviceName: string) => mixed
    ): this;

    /**
     * (Server-only)
     */
    on(
      event: 'USERAUTH_REQUEST',
      listener: (
        username: string,
        serviceName: string,
        authMethod: string,
        authMethodData: AuthMethodData
      ) => mixed
    ): this;

    /**
     * (Server-only)
     */
    on(
      event: 'USERAUTH_INFO_RESPONSE',
      listener: (responses: string[]) => mixed
    ): this;

    /**
     * Emitted when the connection has authenticated.
     */
    on(event: 'ready', listener: () => mixed): this;

    /**
     * Emitted when the socket has disconnected.
     */
    on(event: 'end', listener: () => mixed): this;

    /**
     * Emitted when the client socket was closed.
     */
    on(event: 'close', listener: () => mixed): this;

    /**
     * Emitted when more requests/data can be sent to the stream.
     */
    on(event: 'continue', listener: () => mixed): this;

    /**
     * Emitted when an error occurred.
     */
    on(event: 'error', listener: (err: any) => mixed): this;

    on(event: string, listener: Function): this
  }

  declare type SSH2StreamConfig = {
    /**
     * Set to true to create an instance in server mode.
     */
    server?: boolean;

    /**
     * If in server mode, an object keyed on host key format.
     */
    hostKeys?: HostKeys;

    /**
     * A message that is sent to clients immediately upon connection, before handshaking begins.
     */
    banner?: string;

    /**
     * A custom server software name/version identifier.
     * @default 'ssh2js' + moduleVersion + 'srv'
     */
    ident?: string;

    /**
     * This is the maximum packet size that will be accepted. It should be 35000 bytes or larger to be compatible with other SSH2 implementations.
     * @default 35000
     */
    maxPacketSize?: number;

    /**
     * This is the highWaterMark to use for the parser stream.
     * @default 32 * 1024
     */
    highWaterMark?: number;

    /**
     * This option allows you to explicitly override the default transport layer algorithms used for the connection. Each value must be an array of valid algorithms for that category. The order of the algorithms in the arrays are important, with the most favorable being first.
     */
    algorithms?: Algorithms;

    /**
     * Set this to a function that receives a single string argument to get detailed (local) debug information.
     */
    debug?: (information: string) => any;
  }

  declare type HostKeys = {
    [format: string]: HostKey;
  }

  declare type HostKey = {
    privatekey: ParsedKey;
    publickey: ParsedKey;
  }

  /**
   * Overrides for the default transport layer algorithms used for the connection.
   *
   * The order of the algorithms in the arrays are important, with the most favorable being first.
   */
  declare type Algorithms = {
    kex?: string[];
    cipher?: string[];
    serverHostKey?: string[];
    hmac?: string[];
    compress?: string[];
  }

  declare type Header = {
    /**
     * (Client-only) An optional greeting message presented by the server.
     */
    greeting?: string;

    /**
     * The raw identification string sent by the remote party.
     */
    identRaw: string;

    /**
     * Contains various version information parsed from identRaw.
     */
    versions: Versions;

    /**
     * Any text that comes after the software name/version.
     */
    comments: string;
  }

  declare type Versions = {
    /**
     * The SSH protocol version supported by the remote party.
     */
    protocol: string;

    /**
     * The software name and version used by the remote party.
     */
    software: string;
  }

  declare type TcpipForwardGlobalRequest = {
    /**
     * The IP address to start/stop binding to.
     */
    bindAddr: string;

    /**
     * The port to start/stop binding to.
     */
    bindPort: number;
  }

  declare type openssh_StreamLocalForwardGlobalRequest = {
    socketPath: string;
  }

  declare type GlobalRequest = TcpipForwardGlobalRequest |
    openssh_StreamLocalForwardGlobalRequest |
    Buffer;

  declare type ChannelOpenConfirmationInfo = {
    recipient: number;
    sender: number;
    window: number;
    packetSize: number;
  }

  declare type ChannelOpenFailureInfo = {
    recipient: number;
    reasonCode: number;
    reason: string;
    description: string;
  }

  declare type X11ChannelInfo = {
    +type: 'x11';
    sender: number;
    window: number;
    packetSize: number;
    data: X11ChannelData;
  }

  declare type X11ChannelData = {
    srcIP: string;
    srcPort: number;
  }

  declare type ForwardedTcpipChannelInfo = {
    +type: 'forwarded-tcpip';
    sender: number;
    window: number;
    packetSize: number;
    data: TcpipChannelData;
  }

  declare type DirectTcpipChannelInfo = {
    +type: 'direct-tcpip';
    sender: number;
    window: number;
    packetSize: number;
    data: TcpipChannelData;
  }

  declare type TcpipChannelData = {
    srcIP: string;
    srcPort: number;
    destIP: string;
    destPort: number;
  }

  declare type openssh_ForwardedStreamLocalChannelInfo = {
    +type: 'forwarded-streamlocal@openssh.com';
    sender: number;
    window: number;
    packetSize: number;
    data: SocketChannelData;
  }

  declare type openssh_DirectStreamLocalChannelInfo = {
    +type: 'direct-streamlocal@openssh.com';
    sender: number;
    window: number;
    packetSize: number;
    data: SocketChannelData;
  }

  declare type SocketChannelData = {
    socketPath: string;
  }

  declare type openssh_AuthAgentChannelInfo = {
    +type: 'auth-agent@openssh.com';
    sender: number;
    window: number;
    packetSize: number;
  }

  declare type SessionChannelInfo = {
    +type: 'session';
    sender: number;
    window: number;
    packetSize: number;
  }

  declare type ChannelOpenInfo = X11ChannelInfo |
    ForwardedTcpipChannelInfo |
    openssh_ForwardedStreamLocalChannelInfo |
    openssh_AuthAgentChannelInfo |
    DirectTcpipChannelInfo |
    openssh_DirectStreamLocalChannelInfo |
    SessionChannelInfo;

  declare type ExitStatusChannelRequest = {
    +request: 'exit-status';
    recipient: number;
    code: number;
  }

  declare type ExitSignalChannelRequest = {
    +request: 'exit-signal';
    recipient: number;
    signal: string;
    coredump: boolean;
    description: string;
  }

  declare type PseudoTtyChannelRequest = {
    +request: 'pty-req';
    recipient: number;
    wantReply: boolean;
    term: string;
    cols: number;
    rows: number;
    width: number;
    height: number;
    modes: any;
  }

  declare type WindowChangeChannelRequest = {
    +request: 'window-change';
    recipient: number;
    cols: number;
    rows: number;
    width: number;
    height: number;
  }

  declare type X11ChannelRequest = {
    +request: 'x11-req';
    recipient: number;
    wantReply: boolean;
    single: boolean;
    protocol: string;
    cookie: string;
    screen: number;
  }

  declare type EnvChannelRequest = {
    +request: 'env';
    recipient: number;
    wantReply: boolean;
    key: string;
    val: string;
  }

  declare type ShellChannelRequest = {
    +request: 'shell';
    recipient: number;
    wantReply: boolean;
  }

  declare type ExecChannelRequest = {
    +request: 'exec';
    recipient: number;
    wantReply: boolean;
    command: string;
  }

  declare type SubsystemChannelRequest = {
    +request: 'subsystem';
    recipient: number;
    wantReply: boolean;
    subsystem: string;
  }

  declare type SignalChannelRequest = {
    +request: 'signal';
    recipient: number;
    signal: string;
  }

  declare type FlowControlChannelRequest = {
    +request: 'xon-xoff';
    recipient: number;
    clientControl: boolean;
  }

  declare type openssh_AuthAgentChannelRequest = {
    +request: 'auth-agent-req@openssh.com';
    recipient: number;
  }

  declare type ChannelRequest = ExitStatusChannelRequest |
    ExitSignalChannelRequest |
    PseudoTtyChannelRequest |
    WindowChangeChannelRequest |
    X11ChannelRequest |
    EnvChannelRequest |
    ShellChannelRequest |
    ExecChannelRequest |
    SubsystemChannelRequest |
    SignalChannelRequest |
    FlowControlChannelRequest;

  declare type PublicKeyAuthMethodData = {
    keyAlgo: string;
    key: Buffer;
    signature?: Buffer;
    blob?: Buffer;
  }

  declare type HostbasedAuthMethodData = {
    keyAlgo: string;
    key: Buffer;
    signature?: Buffer;
    blob?: Buffer;
    localHostname: string;
    localUsername: string;
  }

  declare type AuthMethodData = string | PublicKeyAuthMethodData | HostbasedAuthMethodData;

  declare type TcpipForwardingConfig = {
    /**
     * Source IP address of outgoing connection.
     */
    srcIP: string;

    /**
     * Source port of outgoing connection.
     */
    srcPort: number;

    /**
     * Destination IP address of outgoing connection.
     */
    destIP: string;

    /**
     * Destination port of outgoing connection.
     */
    destPort: number;
  }

  declare type X11ForwardingConfig = {
    /**
     * true if only a single connection should be forwarded.
     */
    single: boolean;

    /**
     * The name of the X11 authentication method used (e.g. MIT-MAGIC-COOKIE-1).
     */
    protocol: string;

    /**
     * The X11 authentication cookie encoded in hexadecimal.
     */
    cookie: string;

    /**
     * The screen number to forward X11 connections for.
     */
    screen: number;
  }

  declare type SocketForwardingConfig = {
    socketPath: string;
  }

  declare interface Prompt {
    prompt: string;
    echo?: boolean;
  }

  declare type ForwardedTcpip = {
    bindAddr: string;
    bindPort: number;
    remoteAddr: string;
    remotePort: number;
  }

  declare type ForwardedX11 = {
    originAddr: string;
    originPort: number;
  }

  declare type ForwardedSocket = {
    socketPath: string;
  }

  declare class SFTPStream extends stream$Transform {
    /**
     * Creates and returns a new SFTPStream instance.
     */
    constructor(remoteIdentRaw: string): void,

    /**
     * Creates and returns a new SFTPStream instance.
     */
    constructor(cfg?: SFTPStreamConfig, remoteIdentRaw?: string): void,

    /**
     * Converts string flags (e.g. `'r'`, `'a+'`, etc.) to the appropriate
     * `SFTPStream.OPEN_MODE` flag mask.
     *
     * Returns `null` if conversion failed.
     */
    static stringToFlags(flagsStr: string): number,

    /**
     * Converts flag mask (e.g. number containing `SFTPStream.OPEN_MODE` values) to the
     * appropriate string value.
     *
     * Returns `null` if conversion failed.
     */
    static flagsToString(flagsMask: number): string,

    /**
     * (Client-only)
     * Downloads a file at `remotePath` to `localPath` using parallel reads for faster throughput.
     */
    fastGet(
      remotePath: string,
      localPath: string,
      options: TransferOptions,
      callback: (err: any) => mixed
    ): void,

    /**
     * (Client-only)
     * Downloads a file at `remotePath` to `localPath` using parallel reads for faster throughput.
     */
    fastGet(
      remotePath: string,
      localPath: string,
      callback: (err: any) => mixed
    ): void,

    /**
     * (Client-only)
     * Uploads a file from `localPath` to `remotePath` using parallel reads for faster throughput.
     */
    fastPut(
      localPath: string,
      remotePath: string,
      options: TransferOptions,
      callback: (err: any) => mixed
    ): void,

    /**
     * (Client-only)
     * Uploads a file from `localPath` to `remotePath` using parallel reads for faster throughput.
     */
    fastPut(
      localPath: string,
      remotePath: string,
      callback: (err: any) => mixed
    ): void,

    /**
     * (Client-only)
     * Returns a new readable stream for `path`.
     */
    createReadStream(path: string, options?: ReadStreamOptions): stream$Readable,

    /**
     * (Client-only)
     * Returns a new writable stream for `path`.
     */
    createWriteStream(
      path: string,
      options?: WriteStreamOptions
    ): stream$Writable,

    /**
     * Reads a file
     * @param options either the encoding (string) or a bag of options
     */
    readFile(path: string, options?: string | ReadFileOptions, callback?: (error: any, data: string | Buffer) => mixed): void;

    /**
     * Writes to a file
     * @param options either the encoding (string) or a bag of options
     */
    writeFile(path: string, data: string | Buffer, options?: string | WriteFileOptions, callback?: (error: any) => mixed): void;

    /**
     * Appends to a file
     * @param options either the encoding (string) or a bag of options
     */
    appendFile(path: string, data: string | Buffer, options?: string | AppendFileOptions, callback?: (error: any) => mixed): void;

    /**
     * (Client-only)
     * Opens a file `filename` for `mode` with optional `attributes`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    open(
      filename: string,
      flags: ReadFlags | WriteFlags | AppendFlags,
      attributes: InputAttributes,
      callback: (err: any, handle: Buffer) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Opens a file `filename` for `mode`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    open(
      filename: string,
      flags: ReadFlags | WriteFlags | AppendFlags,
      callback: (err: any, handle: Buffer) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Closes the resource associated with `handle` given by `open()` or `opendir()`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    close(handle: Buffer, callback: (err: any) => mixed): boolean,

    /**
     * (Client-only)
     * Reads `length` bytes from the resource associated with `handle` starting at `position`
     * and stores the bytes in `buffer` starting at `offset`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    readData(
      handle: Buffer,
      buffer: Buffer,
      offset: number,
      length: number,
      position: number,
      callback: (
        err: any,
        bytesRead: number,
        buffer: Buffer,
        position: number
      ) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    writeData(
      handle: Buffer,
      buffer: Buffer,
      offset: number,
      length: number,
      position: number,
      callback: (err: any) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Retrieves attributes for the resource associated with `handle`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    fstat(
      handle: Buffer,
      callback: (err: any, stats: Stats) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Sets the attributes defined in `attributes` for the resource associated with `handle`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    fsetstat(
      handle: Buffer,
      attributes: InputAttributes,
      callback: (err: any) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Sets the access time and modified time for the resource associated with `handle`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    futimes(
      handle: Buffer,
      atime: number | Date,
      mtime: number | Date,
      callback: (err: any) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Sets the owner for the resource associated with `handle`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    fchown(
      handle: Buffer,
      uid: number,
      gid: number,
      callback: (err: any) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Sets the mode for the resource associated with `handle`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    fchmod(
      handle: Buffer,
      mode: number | string,
      callback: (err: any) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Opens a directory `path`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    opendir(
      path: string,
      callback: (err: any, handle: Buffer) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Retrieves a directory listing.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    readdir(
      location: string | Buffer,
      callback: (err: any, list: FileEntry[]) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Checks whether the given file or path exists.
     */
    exists(path: string, callback: (exists: boolean) => mixed): void,

      /**
     * (Client-only)
     * Removes the file/symlink at `path`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    unlink(path: string, callback: (err: any) => mixed): boolean,

    /**
     * (Client-only)
     * Renames/moves `srcPath` to `destPath`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    rename(
      srcPath: string,
      destPath: string,
      callback: (err: any) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Creates a new directory `path`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    mkdir(
      path: string,
      attributes: InputAttributes,
      callback: (err: any) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Creates a new directory `path`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    mkdir(path: string, callback: (err: any) => mixed): boolean,

    /**
     * (Client-only)
     * Removes the directory at `path`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    rmdir(path: string, callback: (err: any) => mixed): boolean,

    /**
     * (Client-only)
     * Retrieves attributes for `path`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    stat(
      path: string,
      callback: (err: any, stats: Stats) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Retrieves attributes for `path`. If `path` is a symlink, the link itself is stat'ed
     * instead of the resource it refers to.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    lstat(
      path: string,
      callback: (err: any, stats: Stats) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Sets the attributes defined in `attributes` for `path`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    setstat(
      path: string,
      attributes: InputAttributes,
      callback: (err: any) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Sets the access time and modified time for `path`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    utimes(
      path: string,
      atime: number | Date,
      mtime: number | Date,
      callback: (err: any) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Sets the owner for `path`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    chown(
      path: string,
      uid: number,
      gid: number,
      callback: (err: any) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Sets the mode for `path`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    chmod(
      path: string,
      mode: number | string,
      callback: (err: any) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Retrieves the target for a symlink at `path`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    readlink(
      path: string,
      callback: (err: any, target: string) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Creates a symlink at `linkPath` to `targetPath`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    symlink(
      targetPath: string,
      linkPath: string,
      callback: (err: any) => mixed
    ): boolean,

    /**
     * (Client-only)
     * Resolves `path` to an absolute path.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    realpath(
      path: string,
      callback: (err: any, absPath: string) => mixed
    ): boolean,

    /**
     * (Client-only, OpenSSH extension)
     * Performs POSIX rename(3) from `srcPath` to `destPath`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    ext_openssh_rename(
      srcPath: string,
      destPath: string,
      callback: (err: any) => mixed
    ): boolean,

    /**
     * (Client-only, OpenSSH extension)
     * Performs POSIX statvfs(2) on `path`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    ext_openssh_statvfs(
      path: string,
      callback: (err: any, fsInfo: any) => mixed
    ): boolean,

    /**
     * (Client-only, OpenSSH extension)
     * Performs POSIX fstatvfs(2) on open handle `handle`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    ext_openssh_fstatvfs(
      handle: Buffer,
      callback: (err: any, fsInfo: any) => mixed
    ): boolean,

    /**
     * (Client-only, OpenSSH extension)
     * Performs POSIX link(2) to create a hard link to `targetPath` at `linkPath`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    ext_openssh_hardlink(
      targetPath: string,
      linkPath: string,
      callback: (err: any) => mixed
    ): boolean,

    /**
     * (Client-only, OpenSSH extension)
     * Performs POSIX fsync(3) on the open handle `handle`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    ext_openssh_fsync(
      handle: Buffer,
      callback: (err: any, fsInfo: any) => mixed
    ): boolean,

    /**
     * (Server-only)
     * Sends a status response for the request identified by `id`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    status(reqID: number, statusCode: number, message?: string): boolean,

    /**
     * (Server-only)
     * Sends a handle response for the request identified by `id`.
     *
     * @param handle A handle must be less than 256 bytes and is an opaque value that could
     *      merely contain the value of a backing file descriptor or some other unique,
     *      custom value.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    handle(reqID: number, handle: Buffer): boolean,

    /**
     * (Server-only)
     * Sends a data response for the request identified by `id`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    data(reqID: number, data: string | Buffer, encoding?: string): boolean,

    /**
     * (Server-only)
     * Sends a name response for the request identified by `id`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    name(reqID: number, names: FileEntry[]): boolean,

    /**
     * (Server-only)
     * Sends an attrs response for the request identified by `id`.
     *
     * Returns `false` if you should wait for the `continue` event before sending any more traffic.
     */
    attrs(reqID: number, attrs: Attributes): boolean,

    /**
     * (Client/Server)
     * Emitted after initial protocol version check has passed.
     */
    on(event: 'ready', listener: () => mixed): this,

    /**
     * (Server-only)
     * Emitted when the client requests to open a file.
     *
     * Respond with:
     * * `handle()` - This indicates a successful opening of the file and passes the given handle back to the client to use to refer to this open file for future operations (e.g. reading, writing, closing).
     * * `status()` - Use this to indicate a failure to open the requested file.
     */
    on(
      event: 'OPEN',
      listener: (
        reqID: number,
        filename: string,
        flags: number,
        attrs: InputAttributes
      ) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests to read data from a file handle.
     *
     * Respond with:
     * * `data()` - Use this to send the requested chunk of data back to the client. The amount of data sent is allowed to be less than the `length` requested.
     * * `status()` - Use this to indicate either end of file (`STATUS_CODE.EOF`) has been reached (`offset` is past the end of the file) or if an error occurred while reading the requested part of the file.
     */
    on(
      event: 'READ',
      listener: (
        reqID: number,
        handle: Buffer,
        offset: number,
        length: number
      ) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests to write data to a file handle.
     *
     * Respond with:
     * * `status()` - Use this to indicate success/failure of the write to the file.
     */
    on(
      event: 'WRITE',
      listener: (
        reqID: number,
        handle: Buffer,
        offset: number,
        data: Buffer
      ) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests attributes for the resource associated with `handle`.
     *
     * Respond with:
     * * `attrs()` - Use this to send the attributes for the requested file/directory back to the client.
     * * `status()` - Use this to indicate an error occurred while accessing the file/directory.
     */
    on(
      event: 'FSTAT',
      listener: (reqID: number, handle: Buffer) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests to write attributes for the resource associated with `handle`.
     *
     * Respond with:
     * * `status()` - Use this to indicates success/failure of the setting of the given file/directory attributes.
     */
    on(
      event: 'FSETSTAT',
      listener: (
        reqID: number,
        handle: Buffer,
        attrs: InputAttributes
      ) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests to close a handle.
     *
     * Respond with:
     * * `status()` - Use this to indicate success (`STATUS_CODE.OK`) or failure of the closing of the file identified by `handle`.
     */
    on(
      event: 'CLOSE',
      listener: (reqID: number, handle: Buffer) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests to open a directory.
     *
     * Respond with:
     * * `handle()` - This indicates a successful opening of the directory and passes the given handle back to the client to use to refer to this open directory for future operations (e.g. reading directory contents, closing).
     * * `status()` - Use this to indicate a failure to open the requested directory.
     */
    on(
      event: 'OPENDIR',
      listener: (reqID: number, path: string) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests to read the contents of a directory.
     *
     * Respond with:
     * * `name()` - Use this to send one or more directory listings for the open directory back to the client.
     * * `status()` - Use this to indicate either end of directory contents (`STATUS_CODE.EOF`) or if an error occurred while reading the directory contents.
     */
    on(
      event: 'READDIR',
      listener: (reqID: number, handle: Buffer) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests attributes for a path. If `path` is a symlink, the
     * link itself should stat'ed instead of the resource it refers to.
     *
     * Respond with:
     * * `attrs()` - Use this to send the attributes for the requested file/directory back to the client.
     * * `status()` - Use this to indicate an error occurred while accessing the file/directory.
     */
    on(
      event: 'LSTAT',
      listener: (reqID: number, path: string) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests attributes for a path.
     *
     * Respond with:
     * * `attrs()` - Use this to send the attributes for the requested file/directory back to the client.
     * * `status()` - Use this to indicate an error occurred while accessing the file/directory.
     */
    on(
      event: 'STAT',
      listener: (reqID: number, path: string) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests to delete a file or symlink.
     *
     * Respond with:
     * * `status()` - Use this to indicate success/failure of the removal of the file at `path`.
     */
    on(
      event: 'REMOVE',
      listener: (reqID: number, path: string) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests to remove a directory.
     *
     * Respond with:
     * * `status()` - Use this to indicate success/failure of the removal of the directory at `path`.
     */
    on(
      event: 'RMDIR',
      listener: (reqID: number, path: string) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests the absolute path for a path.
     *
     * Respond with:
     * * `name()` - Use this to respond with a normalized version of `path`. No file/directory attributes are required to be sent in this response.
     * * `status()` - Use this to indicate a failure in normalizing `path`.
     */
    on(
      event: 'REALPATH',
      listener: (reqID: number, path: string) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests the target for a symlink at `path`.
     *
     * Respond with:
     * * `name()` - Use this to respond with the target of the symlink at `path`. No file/directory attributes are required to be sent in this response.
     * * `status()` - Use this to indicate a failure in reading the symlink at `path`.
     */
    on(
      event: 'READLINK',
      listener: (reqID: number, path: string) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests to set the attributes defined in `attrs` for `path`.
     *
     * Respond with:
     * * `status()` - Use this to indicates success/failure of the setting of the given file/directory attributes.
     */
    on(
      event: 'SETSTAT',
      listener: (
        reqID: number,
        path: string,
        attrs: InputAttributes
      ) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests a new directory be created.
     *
     * Respond with:
     * * `status()` - Use this to indicate success/failure of the creation of the directory at `path`.
     */
    on(
      event: 'MKDIR',
      listener: (
        reqID: number,
        path: string,
        attrs: InputAttributes
      ) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests a path be renamed.
     *
     * Respond with:
     * * `status()` - Use this to indicate success/failure of the renaming of the file/directory at `oldPath` to `newPath`.
     */
    on(
      event: 'RENAME',
      listener: (
        reqID: number,
        oldPath: string,
        newPath: string
      ) => mixed
    ): this,

    /**
     * (Server-only)
     * Emitted when the client requests a new symlink be created for a path.
     *
     * Respond with:
     * * `status()` - Use this to indicate success/failure of the symlink creation.
     */
    on(
      event: 'SYMLINK',
      listener: (
        reqID: number,
        linkPath: string,
        targetPath: string
      ) => mixed
    ): this,

    /**
     * Emitted when the socket has disconnected.
     */
    on(event: 'end', listener: () => mixed): this,

    /**
     * Emitted when the client socket was closed.
     */
    on(event: 'close', listener: () => mixed): this,

    /**
     * Emitted when more requests/data can be sent to the stream.
     */
    on(event: 'continue', listener: () => mixed): this,

    /**
     * Emitted when an error occurred.
     */
    on(event: 'error', listener: (err: any) => mixed): this,

    on(event: string, listener: Function): this
  }

  /**
   * Contains the various status codes (for use especially with SFTPStream#status())
   */
  declare var SFTPStream$STATUS_CODE$OK: 0;
  declare var SFTPStream$STATUS_CODE$EOF: 1;
  declare var SFTPStream$STATUS_CODE$NO_SUCH_FILE: 2;
  declare var SFTPStream$STATUS_CODE$PERMISSION_DENIED: 3;
  declare var SFTPStream$STATUS_CODE$FAILURE: 4;
  declare var SFTPStream$STATUS_CODE$BAD_MESSAGE: 5;
  declare var SFTPStream$STATUS_CODE$NO_CONNECTION: 6;
  declare var SFTPStream$STATUS_CODE$CONNECTION_LOST: 7;
  declare var SFTPStream$STATUS_CODE$OP_UNSUPPORTED: 8;
  declare type SFTPStream$STATUS_CODE =
    typeof SFTPStream$STATUS_CODE$OK |
    typeof SFTPStream$STATUS_CODE$EOF |
    typeof SFTPStream$STATUS_CODE$NO_SUCH_FILE |
    typeof SFTPStream$STATUS_CODE$PERMISSION_DENIED |
    typeof SFTPStream$STATUS_CODE$FAILURE |
    typeof SFTPStream$STATUS_CODE$BAD_MESSAGE |
    typeof SFTPStream$STATUS_CODE$NO_CONNECTION |
    typeof SFTPStream$STATUS_CODE$CONNECTION_LOST |
    typeof SFTPStream$STATUS_CODE$OP_UNSUPPORTED;

  /**
   * Contains the various open file flags
   */
  declare var SFTPStream$OPEN_MODE$READ: 0x00000001;
  declare var SFTPStream$OPEN_MODE$WRITE: 0x00000002;
  declare var SFTPStream$OPEN_MODE$APPEND: 0x00000004;
  declare var SFTPStream$OPEN_MODE$CREAT: 0x00000008;
  declare var SFTPStream$OPEN_MODE$TRUNC: 0x00000010;
  declare var SFTPStream$OPEN_MODE$EXCL: 0x00000020;
  declare type SFTPStream$OPEN_MODE =
    typeof SFTPStream$OPEN_MODE$READ |
    typeof SFTPStream$OPEN_MODE$WRITE |
    typeof SFTPStream$OPEN_MODE$APPEND |
    typeof SFTPStream$OPEN_MODE$CREAT |
    typeof SFTPStream$OPEN_MODE$TRUNC |
    typeof SFTPStream$OPEN_MODE$EXCL;

  declare type SFTPStreamConfig = {
    /**
     * Set to true to create an instance in server mode.
     */
    server?: boolean;

    /**
     * This is the highWaterMark to use for the stream.
     */
    highWaterMark?: number;

    /**
     * Set this to a function that receives a single string argument to get detailed (local) debug information.
     */
    debug?: (information: string) => any;
  }

  declare type TransferOptions = {
    /**
     * Number of concurrent reads
     */
    concurrency?: number;

    /**
     * Size of each read in bytes
     */
    chunkSize?: number;

    /**
     * Called every time a part of a file was transferred
     */
    step?: (total_transferred: number, chunk: number, total: number) => mixed;
  }

  declare type ReadStreamOptions = {
    flags?: string;
    encoding?: string;
    handle?: Buffer;
    mode?: number;
    autoClose?: boolean;
    start?: number;
    end?: number;
  }

  declare type WriteStreamOptions = {
    flags?: string;
    encoding?: string;
    mode?: number;
  }

  declare type ReadFlags = 'r' | 'r+';
  declare type WriteFlags = 'w' | 'wx' | 'xw' | 'w+' | 'wx+' | 'xw+';
  declare type AppendFlags = 'a' | 'ax' | 'xa' | 'a+' | 'ax+' | 'xa+';

  declare type ReadFileOptions = {
    flag?: ReadFlags;
    encoding?: ?string;
  }

  declare type WriteFileOptions = {
    flag?: WriteFlags | AppendFlags;
    encoding?: ?string;
    mode?: number;
  }

  declare type AppendFileOptions = {
    flag?: WriteFlags;
    encoding?: ?string;
    mode?: number;
  }

  declare type FileEntry = {
    filename: string;
    longname: string;
    attrs: Attributes;
  }

  declare type InputAttributes = {
    mode?: number | string;
    uid?: number;
    gid?: number;
    size?: number;
    atime?: number | Date;
    mtime?: number | Date;
  }

  declare type Attributes = {
    mode: number;
    uid: number;
    gid: number;
    size: number;
    atime: number;
    mtime: number;
  }

  declare type Stats = Attributes & {
    isDirectory(): boolean;
    isFile(): boolean;
    isBlockDevice(): boolean;
    isCharacterDevice(): boolean;
    isSymbolicLink(): boolean;
    isFIFO(): boolean;
    isSocket(): boolean;
  }

  declare function utils$parseKey(keyData: string | Buffer): ParsedKey | Error;
  declare function utils$genPublicKey(privKeyInfo: ParsedKey): ParsedKey;
  declare function utils$decryptKey(privKeyInfo: ParsedKey, passphrase: string): void;
}
